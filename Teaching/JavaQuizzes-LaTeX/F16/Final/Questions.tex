\documentclass[CS180-S16-FinalExam.tex]{subfiles}
\begin{document}

%\section*{Part A -- Multiple Choice Questions}
\begin{enumerate}
\section*{One Point Questions}
\label{sec:one}

%\item Sample question
%\begin{lstlisting}
%public static void main(String[] args) {
%	// sample code
%}
%\end{lstlisting}
%\begin{enumerate}[I]
%\item Some statement \texttt{void methodName()}
%\item Some statement
%\end{enumerate}
%\begin{enumerate}
%\item Sample answer
%\item Sample answer
%\item Sample answer
%\item Sample answer
%\item Sample answer \ifdraft \Ans \fi
%\end{enumerate}

%\subsection*{Strings (4 questions)}

\item  Which of the following statements converts a \texttt{String} referenced by \texttt{str} to a \texttt{double} value? 
\begin{enumerate}[I]
\item \texttt{double d1 = str;}
\item \texttt{double d1 = Double.valueOf(str1);}
\item \texttt{double d1 = Double.parseDouble(str1);}
\end{enumerate}

\begin{enumerate}
\item I only
\item II only
\item III only
\item either II or III \ifdraft \Ans \fi
\item either I or II or III 
\end{enumerate}

\item What will be the output of the following program?
\begin{lstlisting}
private class Test {
	public static void main(String[] args) {
		String name = "CS180";
		name.concat(" Fall 2016");
        System.out.printf("%s", name);
    }
}
\end{lstlisting}

\begin{enumerate}
\item CS180 \ifdraft \Ans \fi
\item CS180 Fall 2016
\item Fall 2016
\item Either (a) or (b)
\item An empty String 
\end{enumerate}

\item What is printed to console after executing the following code?
\begin{lstlisting}
boolean b = (new String("Good Luck")) == (new String("Good Luck"));
System.out.println(b);


\end{lstlisting}

\begin{enumerate}
\item  \texttt{True} 
\item  \texttt{False} \ifdraft \Ans \fi
\item The traceback of a  \texttt{NullPointerException}
\item  \texttt{Good Luck}
\item  \texttt{Good Luck == Good Luck}
\end{enumerate}

\clearpage
\item What value will be referenced by \texttt{str} after performing the following operation?
\begin{lstlisting}
String str = "racecar";
str = str.substring(str.indexOf("c"), str.indexOf("c") + 2);
\end{lstlisting}

\begin{enumerate}
\item racecar 
\item cecar
\item ce \ifdraft \Ans \fi
\item cec
\item An \texttt{ArrayIndexOutOfBoundsException} would be thrown.
\end{enumerate}

%\subsection*{Numerical Data (3 questions)}


%\item (Lorenzo)
%Which of the following assertion(s) is(are) false?

%\begin{enumerate}[I]
%\item mixing numerical value types in expressions is \textbf{never} allowed 
%\item A value of type int can be assigned to a variable of type double 
%\item A value of type double cannot be directly assigned to a variable of type int 
%\item To assign a value of type double to a variable of type int, a type casting is needed 
%\item Assigning a value of type float to a variable of type double is a downcast  
%\end{enumerate}

%\begin{enumerate}
%\item I 
%\item IV 
%\item V 
%\item I and V \ifdraft \Ans \fi
%\item I and III
%\end{enumerate}


%\item (Sahil) What will be the result of the following operation?
%\begin{lstlisting}
%5 >> 2 <<< 3
%\end{lstlisting}
%Given the binary values:

%5 = 10010000\\
%2 = 00100000\\
%3 = 00110000
%\newcommand*\xor{\mathbin{\oplus}}
%\begin{enumerate}
%\item TODO
%\item TODO
%\item TODO
%\item TODO
%\item TODO
%\end{enumerate}

\item  Which of the following statements is/are true for primitive types (i.e. \texttt{byte}, \texttt{short}, \texttt{int}, \texttt{long}, \texttt{float}, \texttt{double}, \texttt{boolean}, and \texttt{char})?
\begin{enumerate}[I]
\item Primitive types have a wrapper class that serves as a class version of that primitive type.
\item Primitive type variables need not be declared before it can be used. 
\item It's not always necessary to assign a value when primitive type variables are declared, as they will be set to a default value. 
\end{enumerate}

\begin{enumerate}
\item I and II only  \ifdraft \Ans \fi
\item I, II and III
\item I and III only
\item I only
\item III only
\end{enumerate}


\item  What is the proper order of variable promotion (up-casting) in Java?

\begin{enumerate}
\item byte $->$ short $->$ int $->$ long $->$ float $->$ double \ifdraft \Ans \fi
\item short $->$ byte $->$ long $->$ int $->$ float $->$ double
\item short $->$ byte $->$ int $->$ float $->$ double $->$ long
\item short $->$ byte $->$ int $->$ long $->$ float $->$ double
\item byte $->$ short $->$ int $->$ long $->$ double $->$ float
\end{enumerate}

%\item (Andrew)
%For the following code fragment, what is the last value of i that will be printed to the console?
%\begin{lstlisting}
%for(int i = 1; i >= 0; i++)
%	System.out.println(i);

%\end{lstlisting}
%\begin{enumerate}
%\item 0 
%\item $2^{31}-1$ 
%\item  $2^{31}+1$   
%\item  $2^{31}$  \Ans
%\item Infinite 
%\end{enumerate}

\clearpage
\item 
Which of the following evaluates to 4.4?

\begin{enumerate}[I]
\item \texttt{11 * 0.4}
\item \texttt{(int) 11 * 0.4}
\item \texttt{11 * (int) 0.4}
\item \texttt{(int)(11 * 0.4)}
 
\end{enumerate}

\begin{enumerate}
\item I only
\item II only
\item III only
\item I and II \ifdraft \Ans \fi
\item II, III and IV
\end{enumerate}
%\subsection*{Classes and Methods (5 questions)}

%\item (Andrew)
%What is a class?
%\begin{enumerate}
%\item A blueprint that from which objects are created. \ifdraft \Ans \fi
%\item A wrong answer.
%\item  A wrong answer. 
%\item  A wrong answer. 
%\item A wrong answer. 
%\end{enumerate}

\item  Consider the general syntax for method definition:
\begin{lstlisting}
accessModifier returnType methodName(parameterList) {
	// some statements
    return returnValue;
}
\end{lstlisting}
What is true for \texttt{returnType} and \texttt{returnValue}?
\begin{enumerate}
\item The statement \texttt{return returnValue} can be omitted for any \texttt{returnType}
\item The \texttt{returnValue} must be the same type as the \texttt{returnType}, or be of a type that Java can convert to \texttt{returnType} without loss of information. \ifdraft \Ans \fi
\item The \texttt{returnValue} can be of any type, but it will be automatically converted to \texttt{returnType} when the method returns to the caller. 
\item If the \texttt{returnType} is \texttt{void} then the \texttt{returnValue} can be of any type. 
\item The \texttt{returnType} can only be \texttt{void} for the \texttt{public static void main(String[] args)} method. 
\end{enumerate}

\item Consider the main method: \texttt{public static void main(String[] args)}. Which of the following statements are true?
\begin{enumerate}
\item Every class must have a \texttt{main} method
\item The \texttt{main} method must be the only static method in a program
\item Only the \texttt{main} method may create objects
\item The \texttt{main} method is where the Java interpreter starts to run the program \ifdraft \Ans \fi
\item A class \texttt{Test.java} without the \texttt{main} method can be directly executed by running: \texttt{java Test} on the command line. 
\end{enumerate}

\clearpage
\item 
Which of the following is \textbf{not} true?
\begin{enumerate}
\item A default constructor is provided if no constructors are explicitly declared in a class. 
\item A class can define any number of constructors.
\item The default constructor always takes no arguments.  
\item  At least one constructor \textbf{must} be explicitly provided. \ifdraft \Ans \fi
\item Constructors are used to create objects from a class.
\end{enumerate}

\item
A class can never have methods of the same name.
\begin{enumerate}
\item True 
\item False \ifdraft \Ans \fi

\end{enumerate}



%\subsection*{Selection (4 questions)}

\item 
Consider the boolean variables \texttt{one}, \texttt{two}, and \texttt{three} such that the value of \texttt{one} is always different form the value of \texttt{two}, and \texttt{three} is always \texttt{true}. Which of the following expressions may evaluate to \texttt{false} ?
\begin{enumerate}
\item \texttt{(one \&\& two) $|$$|$ three}
\item \texttt{!(one \&\& two) \&\& three}
\item  \texttt{(one $|$$|$ two) \&\& three}
\item \texttt{one \&\& ( two \&\& three )}\ifdraft \Ans \fi
\item  \texttt{one $|$$|$ two $|$$|$  three}
\end{enumerate}

%\item (Andrew) How does the following statement evaluate?
%\begin{lstlisting}
%(1.000001-0.000001) == 0
%\end{lstlisting}

%\begin{enumerate}
%\item True
%\item False
%\end{enumerate}

\item
Consider the two following code snippets
\begin{lstlisting}
// Option 1
if ( num > 0 )   
  if ( num < 10 ) 
    System.out.println( "aaa" ) ;
  else
    System.out.println( "bbb" ) ;
 
// Option 2
if ( num > 0 )   
   if ( num < 10 ) 
      System.out.println( "aaa" ) ;
else
   System.out.println( "bbb" ) ;
\end{lstlisting}
Since Java doesn't pay attention to indentation, these two snippets are equivalent. For \texttt{num = 0}, what will be printed?
\begin{enumerate}
\item Nothing will be printed as the else will be associated with the inner if.  \ifdraft \Ans \fi
\item \texttt{bbb} will be printed as the else will be associated with the outer if.
\item \texttt{aaa} will be printed
\item Java won't allow any if statements to be compiled without the use of brackets. \{\}
\item  The behavior is not deterministic, different executions con give us different results. 
\end{enumerate}

\item What will be printed by the following code when \texttt{a = 0}?
\begin{lstlisting}
if (a < 1) {
	System.out.printf("1");
} else if (a < 2) {
	System.out.printf("2");
} else {
	System.out.printf("3");
}
\end{lstlisting}
\begin{enumerate}
\item 1 \ifdraft \Ans \fi
\item 2
\item 3
\item 12
\item 123
\end{enumerate}

\item 
What is the output of the following code if the value of \texttt{i} (of type \texttt{int}) is 10 when it is executed?\begin{lstlisting}
switch (i) {
	case 1:  System.out.println("January");
	case 2:  System.out.println("February");
    case 3:  System.out.println("March");
    case 4:  System.out.println("April");
    case 5:  System.out.println("May");
    case 6:  System.out.println("June");
    case 7:  System.out.println("July");
    case 8:  System.out.println("August");
    case 9:  System.out.println("September");
    case 10: System.out.println("October");
    case 11: System.out.println("November"); break;
    case 12: System.out.println("December"); break;
    default: System.out.println("Finished");
}

\end{lstlisting}
\begin{enumerate}
\item  \texttt{October} 
\item  \texttt{October}\\ \texttt{November} \ifdraft \Ans \fi
\item   \texttt{October}\\ \texttt{November}\\ \texttt{December}
\item  \texttt{October}\\ \texttt{November}\\ \texttt{December}\\ \texttt{Finished}
\item  \texttt{Finished}
\end{enumerate}


\item What will the following method return after a call to \texttt{howCold(50);}?
\begin{lstlisting}
public String howCold(int temp) {
	if(temp <= 50) {
    	if(temp < 33) 
        	return "Freezing";
    } else {
    	return "Cold";
    }
    return null;
}
\end{lstlisting}
\begin{enumerate}
\item  \texttt{Freezing}
\item  \texttt{Cold}
\item  \texttt{null} \ifdraft \Ans \fi
\item  \texttt{FreezingCold}
\item  \texttt{ColdFreezing}
\end{enumerate}

%\subsection*{Repetition (5 questions)}
\item What statement or statements will be executed repeatedly as long as x is less than y?
\begin{lstlisting}
1   while (x<y)
2       x = x+7;
3       y = y-4;
4   z = 5;
5   w = x-z;
\end{lstlisting}

\begin{enumerate}
\item Statements in lines 2 and 3
\item Statements in lines  2, 3, and 4
\item Statement in lines 2, 3, 4, and 5
\item Statement in line 2 \ifdraft \Ans \fi
\item Statement in line 4
\end{enumerate}

\clearpage
\item Which is the last value printed to the console after executing the following code?
\begin{lstlisting}
int i = 2;
do {
	i++;
	System.out.println(i);
}
while(i < 2);
\end{lstlisting}

\begin{enumerate}
\item 2 
\item 3 \ifdraft \Ans \fi
\item Nothing is printed to the console
\item This is an infinite loop
\item i
\end{enumerate}

\item Does the following program print out exactly four lines (yes/no).  .
\begin{lstlisting}
public class Q2 {
   public static void increment(int x) {
      x=x+2;
   }
   public static void main(String[] args) {
      int x = 0;
      while(x<8) {
         increment(x);
         System.out.println(x);
      }
  }
}
\end{lstlisting}
\begin{enumerate}
\item Yes
\item No \ifdraft \Ans \fi
\end{enumerate}

\item Assuming that the initial value of \textit{i} is 0, how many more or less iterations does I run compared to II?
\begin{lstlisting}
I.  while(i++ < 5){...something}
II. while(++i < 5){...something}
\end{lstlisting}

\begin{enumerate}
\item 1 more \ifdraft \Ans \fi
\item 1 less
\item 2 more
\item 2 less
\item They have the same number of iterations
\end{enumerate}

\item In a nested for loop (i.e. a for loop within a for loop), calling break inside the inner for loop will only break out of that inner loop. 

\begin{enumerate}
\item True \ifdraft \Ans \fi
\item False
\end{enumerate}

\item How many times is the if statement executed?
\begin{lstlisting}
int i = 0;
while(i < 5) {
	while(i < 5) {
      if(i % 2 == 0)
        continue;
      i++;
	}
}
\end{lstlisting}

\begin{enumerate}
\item 5 times
\item 10 times
\item 50 times
\item Infinite times \ifdraft \Ans \fi
\item 0 times
\end{enumerate}

%\subsection*{Arrays (4 questions)}


\item What will be the value of \texttt{myArray[1]} after executing line 10?
\begin{lstlisting}[numbers=left]
public class ArrayQ {
	public static void modify(int[] array) {
    	for(int i = 0; i < array.length; i++) {
        	array[i] = array[i] * 10;
        }
    }
    
    public static void main(String[] args) {
    	int[] myArray = {1,2,3}
        modify(myArray);
    }
}
\end{lstlisting}

\begin{enumerate}
\item 1
\item 2
\item 10
\item 20 \ifdraft \Ans \fi
\item 0
\end{enumerate}
\clearpage
\item Which of the following code snippets is the correct one to create the ragged array \textit{distance} depicted below?
\begin{lstlisting}
0.00 0.00 0.00 0.00
0.00 0.00 0.00
0.00 0.00
0.00
\end{lstlisting}
\begin{enumerate}
\item \begin{lstlisting}
double[][] distance = new double[4][]; 
for (i = 0; i < distance.length; i++) { 
	distance[i] = new double[i + 1]           
} 
for (i = 0; i < distance[0].length; i++)
    for (j = 0; j < distance[i].length; j++)  {
    distance[i][j] = 0.0;
    }
\end{lstlisting}

\item distance = new double[1][4];

\item  \begin{lstlisting}
double[][] distance = new double[][4];
for (i = 0; i < 4; i++) {
	distance[i] = new double[1 + 1];
}
for (i = 0; i < distance[0].length; i++)
    for (j = 0; j < distance[i].length; j++)  {
    distance[i][j] = 0.0;
    }
\end{lstlisting}

\item  \begin{lstlisting}
double[][] distance; new double[][4];
for (i = 0; i < 4; i++) {
	distance[i] = new double[distance.length-i];
}
\end{lstlisting}

\item  \ifdraft \Ans \fi
\begin{lstlisting}
double[][] distance = new double[4][];
for (i = 0; i < distance.length; i++) { 
	distance[i] = new double[distance.length-i]           
}
for (i = 0; i < distance[0].length; i++)
    for (j = 0; j < distance[i].length; j++)  {
    distance[i][j] = 0.0;
    }
\end{lstlisting}
\end{enumerate}

%\item Which of the following is NOT a valid declaration of an array
%\begin{enumerate}
%\item \texttt{int[] arr = \{1,2,3\}}
%\item \texttt{int[] arr = new int[3]}
%\item \texttt{int[] arr = new int[]\{1,2,3\};}
%\item \texttt{int[] arr; }
%\item \texttt{int[] arr = }
%\end{enumerate}
\clearpage
\item 
Which of the following arrays arr has length 2 (i.e. arr.length gives 2)?

\begin{lstlisting}
I. 	int[][] arr = new int[2][];
II.	int[][] arr = {{1,2,3},{4,5,6}};
III. int[][] arr = new int[][]{{1,2},{4,5}};
\end{lstlisting}

\begin{enumerate}
\item I only
\item II only
\item III only
\item I and II only
\item I, II and III \ifdraft \Ans \fi
\end{enumerate}

\item Which of these correctly traverses a non-square jagged array \textit{arr}?

\begin{enumerate}
\item \begin{lstlisting}
for(int i = 0; i < arr.length ; i++){
	for(int j = 0; j < arr.length; j++)
}
\end{lstlisting}

\item \begin{lstlisting}
for(int i = 0; i < arr[i].length ; i++){
	for(int j = 0; j < arr.length; j++)
}
\end{lstlisting}

\item  \ifdraft \Ans \fi
\begin{lstlisting}
for(int i = 0; i < arr.length ; i++){
	for(int j = 0; j < arr[i].length; j++)
}
\end{lstlisting} 

\item  \begin{lstlisting}
for(int i = 0; i < arr[j].length ; i++){
	for(int j = 0; j < arr.length; j++)
}
\end{lstlisting}

\item \begin{lstlisting}
for(int i = 0; i < arr.length ; i++){
	for(int j = 0; j < arr[j].length; j++)
}
\end{lstlisting}
\end{enumerate}

%\item (Andrew) What is the content of array \textit{arr} after the method call to \textit{zeroOut()}?
%\begin{lstlisting}
%public static void zeroOut(int[] input){
%		for(int i = 0; i < input.length; i++)
%			input[i] = 0;
%}

%public static void main(String[] args){
%	int[] arr = {1, 2, 3, 4};
%    zeroOut(arr);
%}
%\end{lstlisting}

%\begin{enumerate}
%\item {1, 2, 3, 4} 
%\item {2, 3, 4, 5}
%\item {1, 1, 1, 1} 
%\item {0, 0, 0, 0} \ifdraft \Ans \fi
%\item An Exception occurs.
%\end{enumerate}

%\subsection*{Inheritance (4 questions)}
%\item (Lorenzo-easy-\textcolor{red}{TO-CHANGE}) Which of the following condition(s) must be satisfied by an \textit{instance method} of a sub-class that \textbf{overrides} an instance method of the superclass? 
%\begin{enumerate}[I]
%\item  The overriding method must have the same name, number and type of parameters
%\item The overriding method must have the same name and return type as the method that it overrides. 
%\item The overriding method must have the same name, number and type of parameters, and return type as the method that it overrides.
%\item The overriding method can also return a subtype of the type returned by the overridden method
%\end{enumerate}
%\begin{enumerate}
%\item I only
%\item II only
%\item either I or II
%\item III only
%\item III and IV \ifdraft \Ans \fi
%\end{enumerate}

\clearpage
\item Which of the following option(s) can be used to restrict a member \texttt{m} of a class from being inherited [accessible] by its sub classes?
\begin{enumerate}[I]
\item By declaring \texttt{m} \texttt{final}
\item By declaring \texttt{m} \texttt{static}
\item By declaring \texttt{m} \texttt{private}
\item By declaring \texttt{m} \texttt{public}
\end{enumerate}
\begin{enumerate}
\item Only I
\item Only II
\item II or III
\item Only III \ifdraft \Ans \fi
\item III or IV 
\end{enumerate}

\item  Which of the following is \textbf{not} true?
\begin{enumerate}[I]
\item class A extends B means A is a subclass of B.
\item A class can extend multiple classes
\item A descendant class can define a method with the same signature as a method defined in an ancestor class
\end{enumerate}
\begin{enumerate}
\item I
\item II \ifdraft \Ans \fi
\item I, III 
\item II, III 
\item I, II, III
\end{enumerate}

\item  Which of the following definitions of class A \textbf{cannot} be extended?
\begin{enumerate}
\item \texttt{class A{}} 
\item \texttt{class A{ private A(); }}
\item \texttt{final class A {}} \ifdraft \Ans \fi
\item \texttt{class A { protected A(); }}
\item \texttt{class A extends B}
\end{enumerate}

\item  Where can the keyword \texttt{super} be used in a subclass constructor to call the superclass constructor?

\begin{enumerate}
\item Only as the very first statement executed. \ifdraft \Ans \fi
\item Only as the very last statement executed. 
\item It can be used anywhere within the constructor.
\item It can be used anywhere within the class.
\item super is not allowed to be used inside the subclass constructor.
\end{enumerate}

\clearpage
%\subsection*{Interfaces (2 questions)}

\item Which of the following statements are true?
\begin{enumerate}
\item  If a class implements an interface, it is making a promise to have a version of each of the methods listed in the interface
\item Java allows a class to implement multiple interfaces
\item An interface can provide implementations for non-default methods
\item (a) and (b)  \ifdraft \Ans \fi
\item (a) and (c)
\end{enumerate}

\item  Which of the following classes properly implements the interface Pokemon?
\begin{lstlisting}
public interface Pokemon {
	public boolean evolve(int candy);
}
\end{lstlisting}

\begin{enumerate}
\item \begin{lstlisting}
public class Charmander implements Pokemon { 
	public boolean evolve() {
		return true;
    }
}
\end{lstlisting}

\item  \ifdraft \Ans \fi \begin{lstlisting}
public class Bulbasaur implements Pokemon {
	public boolean evolve(int candy) {
		return (candy > 25);
	}
}
\end{lstlisting}

\item \begin{lstlisting}
public class Squirtle {
	public boolean evolve(int candy) {
		return (candy > 25);
	}
}
\end{lstlisting}

\item \begin{lstlisting}
public class Pikachu implements Pokemon { 
	private boolean evolve(int candy) {
		return (candy > 50);
	}
}
\end{lstlisting}

\item
\begin{lstlisting}
public class Mewtwo implements Pokemon {
	public boolean evolve(Pokemon pokemon) {
		return false;
    }
} 
\end{lstlisting}
\end{enumerate}

\item Assume \texttt{Child} is a subclass of \texttt{Parent}. What is the output of the following code?
\begin{lstlisting}
Child c = new Child();
if(c instanceof Parent)
   System.out.println("c is of type Parent");
if(c instanceof Child)
   System.out.println("c is of type Child");
\end{lstlisting}
\begin{enumerate}
\item \texttt{c is of type Parent}\\\texttt{c is of type Child} \ifdraft \Ans \fi
\item \texttt{c is of type Parent}
\item \texttt{c is of type Child}
\item Nothing would be printed as \texttt{c} is not an instance of either \texttt{Child} or \texttt{Parent}
\end{enumerate}

\item  Assume \texttt{Car} is a class that implements an interface \texttt{Vehicle}. What is the output of the following code?
\begin{lstlisting}
Vehicle v = new Car();
if(v instanceof Vehicle)
   System.out.println("c is of type Vehicle");
if(v instanceof Car)
   System.out.println("v is of type Car");
\end{lstlisting}
\begin{enumerate}
\item \texttt{c is of type Vehicle}\\\texttt{c is of type Car} \ifdraft \Ans \fi
\item \texttt{c is of type Vehicle}
\item \texttt{c is of type Car}
\item Nothing would be printed as \texttt{v} is not an instance of either \texttt{Vehicle} or \texttt{Car}
\end{enumerate}

%\subsection*{GUIs / MVC (1 question)}

%\item (BD quiz) Which of the following will create a JPanel object managed by the FlowLayout manager?
%\begin{enumerate}
%\item JPanel panel = new JPanel(); 
%\item JPanel panel = new JPanel(new FlowLayout());
%\item JPanel panel = new JPanel(new Layout()); 
%\item Both A and B \ifdraft \Ans \fi
%\item All of A, B, and C
%\end{enumerate}

\item Which of the following correctly pops up a showInputDialog box and puts the result in
the integer variable age?
\begin{enumerate}
\item int age = \texttt{JOptionPane.showInputDialog("What is your age?");}
\item int age =  \texttt{Integer.parseInt(JOptionPane.showInputDialog("What is your age?"));} \ifdraft \Ans \fi
\item int age =  \texttt{JOptionPane.parseInt(JOptionPane.showInputDialog("What is your age?"));} 
\item  \texttt{String age = JOptionPane.showInputDialog("What is your age?");}
\item  \texttt{String age = JOptionPane.showConfirmDialog("What is your age?");}
\end{enumerate}

\clearpage
%\subsection*{Exceptions (3 questions)}
\item What will be the output of the following program?
\begin{lstlisting}
class Test {
    public static void main (String[] args) {
        try {
            int a = 0;
            System.out.println ("a = " + a + "\n");
            int b = 20 / a;
            System.out.println ("b = " + b);
        } catch(ArithmeticException e) {
            System.out.println ("Divide by zero error");
        } finally {
            System.out.println ("Inside the finally block");
        }
    }
}
\end{lstlisting}

\begin{enumerate}
\item \texttt{a = 0}\\ \texttt{Divide by zero error}\\ \texttt{Inside the finally block} \ifdraft \Ans \fi
\item \texttt{Divide by zero error}\\ \texttt{Inside the finally block}
\item \texttt{a = 0}\\ \texttt{Divide by zero error}
\item \texttt{Inside the finally block}
\item \texttt{Divide by zero error}\\
\end{enumerate}

\clearpage
\item Consider the following code:
\begin{lstlisting}
class Test {
    public static void main(String[] args) {
        try {
            int a[]= {1, 2, 3, 4};
            for (int i = 1; i <= 4; i++) {
                System.out.println ("a[" + i + "]=" + a[i] + "\n");
            }
        } catch (Exception e) {
            System.out.println ("error = " + e);
        } catch (ArrayIndexOutOfBoundsException e) {
            System.out.println ("ArrayIndexOutOfBoundsException");
        }
    }
}
\end{lstlisting}
Is the \texttt{ArrayIndexOutOfBoundsException} reachable and why?
\begin{enumerate}
\item Yes, because Java lets us catch any number of different exceptions.
\item No, because only one exception can be caught for a snippet of code.
\item No, because \texttt{Exception} is a superclass of
\texttt{ArrayIndexOutOfBoundsException} and \texttt{catch} statements are evaluated in order. \ifdraft \Ans \fi
\item Yes, because \texttt{catch} statements are not evaluated in order. 
\item No, because the \texttt{main} method doesn't include \texttt{throws ArrayIndexOutOfBoundsException} in its signature. 
\end{enumerate}

\item Java will let you run the \texttt{Thread} class methods \texttt{sleep()} and \texttt{join()} only if you catch a possible \texttt{InterruptedException}. This tells us that the \texttt{InterruptedException} is a/an \noindent\rule{3cm}{0.4pt} Exception.
\begin{enumerate}
\item Checked \ifdraft \Ans \fi
\item Unchecked
\item Thread
\item Runnable
\item Object
\end{enumerate}

%\subsection*{Files (3 questions)}
\item What interface does a class need to implement for its instances to be writable to a file using \texttt{ObjectOutputStream}?
\begin{enumerate}
\item Iterable
\item Serializable \ifdraft \Ans \fi
\item Throwable
\item Comparable
\item Runnable
\end{enumerate}

\clearpage
\item Given that static binding in Java occurs during Compile time while Dynamic binding occurs during Runtime. Which of the following statements are true?
\begin{enumerate}[I]
\item Method overriding is an example of static binding 
\item Method overriding is an example of dynamic binding 
\item All the static, private and final methods are bonded at compile time
\end{enumerate}
\begin{enumerate}
\item II only
\item III only
\item I and III
\item II and III \ifdraft \Ans \fi
\item I only
\end{enumerate}

%\subsection*{Network Communication (2 questions)}
\item Which if the following statements are true?
\begin{enumerate}
\item For a client program to communicate with a server, it needs to create a Socket to connect to the server using the server's IP or hostname.
\item For a client program to communicate with the server, it needs to call the \texttt{accept()} method on a Socket object.
\item Client and server can't run on the same computer with the same IP address.
\item (a) and (b) \ifdraft \Ans \fi
\item (a), (b) and (c)
\end{enumerate}

\item Which of the following statements is NOT true?
\begin{enumerate}
\item A server program has to create a \texttt{ServerSocket} object for a given port
\item When the method \texttt{accept();} is called on a \texttt{ServerSocket} object, the program stays waiting for an incoming connection.
\item The port used to create the \texttt{ServerSocket} object is the port that clients will need to use to connect to the server.
\item A server can only accept connections from a single client.  \ifdraft \Ans \fi
\item The \texttt{accept()} method will return a \texttt{Socket} that can be used to read and write from and to the client.
\end{enumerate}

\clearpage
%\subsection*{Concurrency (2 questions)}
\item Which of the following statements is/are true?
\begin{enumerate}[I]
\item In Java, a programmer can create a number of threads which share the same memory space.
\item Every Java program has at least one thread.
\item A concurrent program is one in which several statements can be executed simultaneously by one or more cores.
\end{enumerate}
\begin{enumerate}
\item II and III
\item II only
\item III only
\item I and II
\item I, II and III \ifdraft \Ans \fi
\end{enumerate}

\clearpage
\item When running the \texttt{main} method of the code below, how may threads will be created?  
\begin{lstlisting}
class AThread extends Thread{
    public static int myCount = 0;
    public void run(){
        while(AThread.myCount < 10){
            try{
                ++AThread.myCount;
                System.out.println("Expl Thread: "+(AThread.myCount));
                Thread.sleep(100);
            } catch (InterruptedException iex) {
                System.out.println("Exception in thread: "+iex.getMessage());
            }
        }
    }
}

public class RunThread {
    public static void main(String a[]){
        System.out.println("Starting Main Thread...");
        AThread mst = new AThread();
        mst.run();
        
        while(AThread.myCount < 10){
            try{
                System.out.println("Main Thread: "+(++AThread.myCount));
                Thread.sleep(100);
            } catch (InterruptedException iex){
                System.out.println("Exception in main thread: "+iex.getMessage());
            }
        }
        System.out.println("End of Main Thread...");
    }
}
\end{lstlisting}


\begin{enumerate}
\item 1
\item 2
\end{enumerate}

\clearpage
\item Which of the following statements is/are true?
\begin{enumerate}[I]
\item Any time a thread enters a piece of code protected by the synchronized keyword, it implicitly acquires a lock which only a single thread can hold.
\item An atomic variable can be read and updated in a single atomic step, avoiding race conditions with other threads.
\item Static variables are inherently synchronized, two threads can use it without running into race conditions.
\end{enumerate}
\begin{enumerate}
\item I and II only \ifdraft \Ans \fi
\item I and III only
\item I, II and III
\item Only I
\item Only III
\end{enumerate}

%\subsection*{Recursion (2 questions)}
\item The following method should compute the sum of all the numbers between 1 and n. What is wrong with it?
\begin{lstlisting}
public static int sum (int n) {
   return (sum(n-1) + n);
}
\end{lstlisting}

\begin{enumerate}
\item It actually computes n!
\item It actually computes $n^2$
\item It actually computes $n*2$
\item It will recurse infinitely \ifdraft \Ans \fi
\item It has no recursive case
\end{enumerate}

\item  What exception will be thrown when executing an infinite recursion?
\begin{enumerate}
\item \texttt{NullPointerException}
\item \texttt{IndexOutOfBoundsException}
\item \texttt{StackOverflowException} \ifdraft \Ans \fi
\item \texttt{ArrayIndexOutOfBounds}
\item \texttt{ArithmeticException}
\end{enumerate}

%\item (Maria) How many base cases must a recursive method have? 
%\begin{enumerate}
%\item 1
%\item at least 1 \ifdraft \Ans \fi
%\item as many cases as inputs in the method
%\item it doesn't necessarily need a base case
%\item 2
%\end{enumerate}

%\subsection*{Data Structures (2 questions)}
%\item (BD quiz) 
%\begin{lstlisting}
%String[] list = new String[10]; 
%ArrayList<String> name = new ArrayList<String>();
%\end{lstlisting}

%Which statement below is equivalent to 
%\textbf {list[i]="Joe";} ?
%\begin{enumerate}
%\item name.add(i,"Joe"); 
%\item name.add("Joe"); 
%\item name.set(i,"Joe"); \ifdraft \Ans \fi
%\item name.set("Joe"); 
%\item name.set(i)="Joe";
%\end{enumerate}
\clearpage
\item In a \texttt{Node} class that implements a \texttt{Linked List}, each node has a variable \texttt{link} that points to the next node. In the following code, which statement correctly completes the following code to walk the list.
\begin{lstlisting}
Node node = list.head;
while (node != list.tail) {
    // your statement
}
\end{lstlisting}

\begin{enumerate}
\item \texttt{node = list.head.link;}
\item \texttt{node = list.tail.link;}
\item \texttt{node = node.link;} \ifdraft \Ans \fi
\item \texttt{node.link = node;}
\item \texttt{node = node;}
\end{enumerate}

\item if A extends B and we create two variables:
\begin{lstlisting}
A a;
B b;
\end{lstlisting}
Which of the following is NOT allowed?
\begin{enumerate}
\item \texttt{b = new A();}
\item \texttt{a = b;}
\item \texttt{b = a;} \ifdraft \Ans \fi
\item \texttt{b = (B) a;}
\item (c) and (d) 
\end{enumerate}
%\subsection*{Polymorphism (1 question)}
\item Given a class A  and the class B depicted below, a variable of type A can hold a reference to an object of type B. \newline
Example:
\begin{lstlisting}
class A{}

public class B extends A{
	public static void main(String[] args){
    	A a = new B();
    }
}

\end{lstlisting}
\begin{enumerate}
\item True\ifdraft \Ans \fi
\item False 
\end{enumerate}


\clearpage

\section*{Two Point Questions}
\label{sec:two}

%\subsection*{User defined classes and methods (4 questions)}
\item 
Consider the following code:
\begin{lstlisting}
public class Methods {
	public static void zero(Point p) {
		p.x = 0;
    	p.y = 0;
	}

	public static void increment(int n) {
		n++;
	}

	public static void modify(int[] a) {
		a = new int[5];
	}
    
    public static void main(String[] args) {
		Point point = new Point(1,1);
        zero(point); 
        
        int number = 10;
        increment(number);
        
        int[] a = {1,1,1}
        modify(a);
    }
}
\end{lstlisting}

Which of the following statements are true?
\begin{enumerate}
\item The fields of the object \texttt{point} have changed after the call made to \texttt{zero} \ifdraft \Ans \fi
\item The value of the variable \texttt{number} has changed after the call made to \texttt{increment}
\item The reference of the object \texttt{a} has changed after the call made to \texttt{modify}
\item (a) and (c)
\item (a), (b) and (c)
\end{enumerate}
\clearpage
\item Consider the following declarations of three Car objects.
\begin{lstlisting}
Car car1 = new Car("Mercedes", "C300 Sport", 75000);
Car car2 = new Car("Pontiac", "Vibe", 17000);
Car car3 = new Car("Mercedes", "C300 Sport", 75000);
\end{lstlisting}
Let same be a variable of type \texttt{boolean}. What is the value of variable \texttt{same} after each of the following statements? Assume that the \texttt{equals()} method will return \texttt{true} if all of the attributes specified by the constructors for the two objects are the same.
\begin{enumerate}[i]
\item \texttt{same = (car1 == car2);}
\item \texttt{same = (car1 == car3);}
\item \texttt{same = (car1.equals(car3));}
\end{enumerate}
\begin{enumerate}
\item false, false, true  \ifdraft \Ans \fi
\item false, true, true
\item false, true, false
\item true, true, true
\item true, false, true
\end{enumerate}
\clearpage
\textbf{The next two questions are based on the following program}
\begin{lstlisting}[numbers=left]
public class Windows10 {
	public static double currentVersion = 1.0;
    public double softwareVersion = 1.0;
    public String userName;
    
    public Windows10(String name) {
    	userName = name;
    }
    
    public Windows10() {
    	this("root");
    }
    
    public static void releaseUpdate() {
    	currentVersion++;
    }
    
    public void performUpdate() {
    	softwareVersion++;
    }
    
    public void performUpdate(double buildNumber) {
        softwareVersion += buildNumber;
    }
    
    public static void main(String[] args) {
		Windows10 a = new Windows10();
		Windows10 b = new Windows10("Bill");
		a.releaseUpdate();       
		a.performUpdate();      
		b.performUpdate(0.1);   
    }
}
\end{lstlisting}

\item What will the values of the following variables be...
\begin{enumerate}[i]
\item \texttt{a.userName}
\item \texttt{b.userName}
\item \texttt{a.currentVersion}
\item \texttt{b.currentVersion}
\end{enumerate}

\clearpage
After statement in line 30 executes?
\begin{enumerate}
\item root, Bill, 2, 2 \ifdraft \Ans \fi
\item null, Bill, 2, 2
\item root, Bill, 1, 1
\item root, Bill, 2, 1
\item null, Bill, 2, 1
\end{enumerate}

\item What will the values of the following variables be...
\begin{enumerate}[i]
\item \texttt{a.softwareVersion}
\item \texttt{b.softwareVersion}
\end{enumerate}

After statements in line 31 and 32 both execute?
\begin{enumerate}
\item 1.1, 2
\item 2, 2
\item 2, 1.1 \ifdraft \Ans \fi
\item 1.1, 1.1
\end{enumerate}

%\subsection*{Arrays (4 questions)}

\textbf{Answer the next two questions based on the following code:}
\begin{lstlisting}
public static int[][] modify(int[][] matrix) {
	for (int i = 0; i < matrix.length; i++) {
    	for (int j = 0; j < matrix.length; j++) {
        	if(i == j)
        		matrix[i][j] = 0;
        }
    }
    return matrix;
}
\end{lstlisting}
\item What output will be produced by a call to \texttt{modify(\{\{1,2,3\},\{4,5,6\},\{7,8,9\}\})} ?
\begin{enumerate}
\item \texttt{\{\{1,2,3\},\{4,5,6\},\{7,8,9\}\}}
\item \texttt{\{\{0,2,3\},\{4,0,6\},\{7,8,0\}\}} \ifdraft \Ans \fi
\item \texttt{\{\{0,0,0\},\{4,0,0\},\{7,8,0\}\}}
\item \texttt{\{\{1,0,0\},\{0,5,0\},\{0,0,9\}\}}
\item An ArrayIndexOutOfBounds exception will be thrown for accessing an invalid position in the array
\end{enumerate}

\clearpage
\item What output will be produced by a call to \texttt{modify(\{\{1,2\},\{3,4\},\{5,6\})} ?
\begin{enumerate}
\item \texttt{\{\{1,2\},\{3,4\},\{5,6\}\}}
\item \texttt{\{\{0,2\},\{3,0\},\{5,6\}\}}
\item \texttt{\{\{0,0\},\{3,0\},\{5,6\}\}}
\item \texttt{\{\{1,0\},\{0,4\},\{0,0\}\}}
\item An \texttt{ArrayIndexOutOfBounds} exception will be thrown for accessing an invalid position in the array \ifdraft \Ans \fi
\end{enumerate}

\item Consider the following method.
\begin{lstlisting}
public static boolean checkProperty(int[][] matrix) {
	for (int i = 0; i < matrix.length; i++) {
    	if(matrix[i][i] != 0)
        	return false;
    }
    return true;
}
\end{lstlisting}
Which of the following statements is/are true?
\begin{enumerate}
\item \texttt{checkProperty(\{\{0,0,0\},\{4,0,0\},\{7,8,0\}\})} will return \texttt{True}
\item \texttt{checkProperty(\{\{0,0,0\},\{4,5,6\},\{7,8,9\}\})} will return \texttt{False}
\item \texttt{checkProperty(\{\{0,2,3\},\{0,0,6\}\})} will throw an \texttt{ArrayIndexOutBounds} exception for accessing an invalid position in the array
\item (a), (b) and (c)
\item (a) and (b)  \ifdraft \Ans \fi
\end{enumerate}

\item The following code defines an int array \textbf{matrix[][]}.
\begin{lstlisting}
int[][] matrix = new int[2][];
matrix[0] = new int[3];
matrix[1] = new int[2];
\end{lstlisting}
Which of the following statements are invalid (i.e. they would generate a compilation error or runtime exception)?
\begin{enumerate}
\item \texttt{matrix[0][2] = 2;}
\item \texttt{matrix[0][0] = 3.5;}
\item \texttt{matrix[1][2] = 5;}
\item (a), (b) and (c)
\item (b) and (c) \ifdraft \Ans \fi
\end{enumerate}

\clearpage
%\subsection*{Inheritance (4 questions)}
\textbf{The following three questions are based on the classes provided below provided below}
\begin{lstlisting}[numbers=left]
public class X {
    public static void staticMethod() {
        System.out.printf("Class X ");
    }
} 
public class Y extends X
{
    public static void staticMethod() {
   		System.out.printf("Class Y ");
    }
}
public class MainClass
{
    public static void main(String[] args) {
        Y.staticMethod();
    }
}
\end{lstlisting}

\item What will the output of this program be?
\begin{enumerate}
\item \texttt{Class X}
\item \texttt{Class Y} \ifdraft \Ans \fi
\item \texttt{Class X Class Y}
\item \texttt{Class Y Class X}
\item This program is not valid
\end{enumerate}

\item If we add the statement: \texttt{super.staticMethod()} above line 9 in the method \texttt{staticMethod} of class Y, what will the output be?
\begin{enumerate}
\item \texttt{Class X}
\item \texttt{Class Y}
\item \texttt{Class X Class Y} \ifdraft \Ans \fi
\item \texttt{Class Y Class X}
\item This program is not valid
\end{enumerate}

\item If we remove the method in line 8, this program would not compile because the \texttt{staticMethod()} is missing for class \texttt{Y} (T/F)
\begin{enumerate}
\item \texttt{True}
\item \texttt{False} \ifdraft \Ans \fi
\end{enumerate}

\clearpage
\item Consider the following class definitions.
\begin{lstlisting}
public class A {
	private String value;
    
    public A(String s) {
    	value = "A" + s + "A";
    }
    
    public String toString(){
    	return value;
    }
}

public class B extends A {
	public B(String s) {
    	super("B" + s + "B");
    }
}

public class C extends B {
	public C(String s) {
		super("C" + s + "C");
    }
}
\end{lstlisting}
What is output by the following code fragment?
\begin{lstlisting}
 C c = new C("ABC");
 System.out.println(c);
\end{lstlisting}
\begin{enumerate}
\item c
\item A string composed of the name of the class, an @ symbol and the hashcode of the object in hexadecimal. For example, C@659e0bfd.
\item ABCABCCBA \ifdraft \Ans \fi
\item BCABCCB
\item CABCC
\end{enumerate}

%\subsection*{Interfaces (2 questions)}

\clearpage
\textbf{Answer the next two questions based on the following code:}
\begin{lstlisting}
public interface InterfaceA {
   void methodA();
}

public interface InterfaceB extends InterfaceA {
   void methodB();
}
   
public class ClassA implements InterfaceA {
	public void methodA() {}
	public void methodB() {}
}

public class ClassB implements InterfaceB {
	public ClassB() {}
	... // methods not shown
}
\end{lstlisting}
\item Which methods must be explicitly defined in \texttt{ClassB} for it to correctly implement \texttt{InterfaceB} and compile with no errors?
\begin{enumerate}
\item No particular methods are required  
\item \texttt{methodA()} only
\item \texttt{methodB()} only 
\item \texttt{methodA()} and \texttt{methodB()} \ifdraft \Ans \fi
\item \texttt{methodA()}, \texttt{methodB()} and \texttt{toString()}
\end{enumerate}

\item  Which of the following statements is invalid and would cause a compilation error?
\begin{enumerate}
\item \texttt{InterfaceA obj = new ClassA()}
\item \texttt{InterfaceB obj = new ClassA()} \ifdraft \Ans \fi
\item \texttt{InterfaceA obj = new ClassB()}
\item \texttt{InterfaceB obj = new ClassB()}
\item (b) and (c)
\end{enumerate}

\clearpage
%\subsection*{Exceptions (3 questions)}
\item The following code segment fails to compile because...
\begin{lstlisting}
try {
	Thread.sleep(1000);
} catch (Exception e) {
    System.out.println("Exception occurred!");
} catch (InterruptedException e) {
    System.out.println("Woke up early!");
}

\end{lstlisting}
\begin{enumerate}
\item it is illegal to put a thread to sleep without a purpose.
\item the method \texttt{sleep} should be preceded by the method \texttt{join}.
\item it is illegal to catch two exceptions.
\item the ordering of catch blocks is incorrect. \ifdraft \Ans \fi 
\item the \texttt{finally} block is missing.
\end{enumerate}

\textbf{The next two questions are based on the following message that a programmer got on running a program.}
\begin{lstlisting}
Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: 18
	at Polynomial.parseInputPolynomial(Polynomial.java:56)
    at Polynomial.<init>(Polynomial.java:217)
    at EvaluatePolynomials.main(EvaluatePolynomials.java:22)
\end{lstlisting}

\item Where does the error occur?
\begin{enumerate}
\item Class: \texttt{java.lang} Method: \texttt{ArrayIndexOutOfBoundsException}
\item Class: \texttt{Polynomial}, Method: \texttt{parseInputPolynomial} \ifdraft \Ans \fi 
\item Class: \texttt{Polynomial}, Method: \texttt{$<$init$>$}
\item Class: \texttt{EvaluatePolynomials} Method: \texttt{main}
\item There is no error. This is a normal output message.
\end{enumerate}

\item What does the number 18 in the first line of the message indicate?
\begin{enumerate}
\item Program tried to access an element of an array of length 18
\item Program tried to access the element of an array at the index 18 \ifdraft \Ans \fi 
\item Program tried to access an element of an array in line 18 of the program
\item The number does not have any significance
\item The error occurred in line number 18
\end{enumerate}

\clearpage
%\subsection*{Files (3 questions)}

\textbf{The next three questions are based on the program provided below}
\begin{lstlisting}[numbers=left]
import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;

public class FileHandle {
	public void parseAndPrint(String filename) {
		File f = new File(filename);
        Scanner in = null;
        try {
        	in = new Scanner(f);
			while (in.hasNextLine()) {
            	String line = in.nextLine();
                String[] tokens = line.split(",");
                int len = tokens.length;
                for (int i = 0; i < len; i++) {
                	System.out.println(tokens[i]);
                }
            } catch (FileNotFoundException e) {
            	System.out.println("File " + f.getName() + " not found");
            } finally {
            	if (in != null)
                	in.close();
            }
        }
        public static void main(String[] args) {
        	String fileName = "input.txt";
            FileHandle fh = new FileHandle();
            fh.parseAndPrint(fileName);
        }
}
\end{lstlisting}

\textbf{The next three questions are based on the program provided below}
\begin{lstlisting}
3
2,2
\end{lstlisting}
\clearpage
\item What is the output of the program?
\begin{enumerate}
\item 3\\2,2
\item  3\\2 2
\item  3\\2\\2 \ifdraft \Ans \fi 
\item 3,2,2
\item 3\\22
\end{enumerate}

\item Which of the following statements is/are true about the program?
\begin{enumerate}[I]
\item Removing the finally block will not change the output.
\item The \texttt{try-catch-finally} work is not necessary to compile this program because \texttt{FileNotFoundException} is an unchecked exception.
\item We can replace \texttt{FileNotFoundException} with \texttt{Exception} to compile this program. 
\end{enumerate}
\begin{enumerate}
\item only I
\item only II
\item only III
\item I and II
\item I and III \ifdraft \Ans \fi 
\end{enumerate}

\item If we replace \textbf{line 13} with: \texttt{String[] tokens = line.split(" ");}. What will be the output of this program? 
\begin{enumerate}
\item 3\\2,2\ifdraft \Ans \fi 
\item 3\\2 2
\item 3\\2\\2
\item 3,2,2
\item 3\\22
\end{enumerate}
\clearpage
%\subsection*{Concurrency (2 questions)}
\textbf{The next two questions are based on the program provided below.}
\begin{lstlisting}[numbers=left]
public class RaceCondition extends Thread {
	static int counter = 0;
    
	public synchronized void run() {
		for (int i = 0; i < 4; i++) {
			counter++;
		}
	}
	public static void main(String[] args) {
		RaceCondition r1 = new RaceCondition();
		r1.start();
		RaceCondition r2 = new RaceCondition();
		r2.start();
		try {
			r1.join();
			r2.join();
		} catch (Exception e) {
        	//
		}
		System.out.printf(r1.counter + " ");
		System.out.println(r2.counter);
	}
}
\end{lstlisting}
\item What does this program print?
\begin{enumerate}
\item 4 4
\item 8 8 \ifdraft \Ans \fi 
\item 2 4
\item 5 7
\item Any of (a), (b), (c) or (d) are possible
\end{enumerate}

\item If we remove lines from 14-19, what does this program print?
\begin{enumerate}
\item 4 4
\item 8 8 
\item 2 4
\item 5 7
\item Any of (a), (b), (c) or (d) are possible \ifdraft \Ans \fi 
\end{enumerate}
\clearpage
%\subsection*{Recursion (2 question)}
\item What does compute(40) return?
\begin{lstlisting}
public static int compute(int x) {
	if (x < 50)
    	x = compute(x + 5);
    return (x - 5);
}
\end{lstlisting}
\begin{enumerate}
\item 40
\item 35  \ifdraft \Ans \fi 
\item 45
\item 50
\item 30
\end{enumerate}

\item Consider the following method:
\begin{lstlisting}
public static int myMethod(int n) {
  if (n == 1)
     return 1;
  else
    return n + myMethod(n - 1);
  }
\end{lstlisting}
What is the return value for the call myMethod(4)?
\begin{enumerate}
\item 8
\item 9
\item 10 \ifdraft \Ans \fi
\item 11
\item 12
\end{enumerate}

%subsection*{Data Structures (1 question)}
\item If a Linked List is used to implement a Stack, which of these would work?
\begin{enumerate}
\item \texttt{push(node)}: make node the head of the Linked List. \\
\texttt{pop()}: return the value of, but do not remove the head of the Linked List.
\item \texttt{push(node)}: make node the head of the Linked List. \\
\texttt{pop()}: remove, but do not return the value of the tail of the Linked List.
\item \texttt{push(node)}: make node the tail of the Linked List. \\
\texttt{pop()}: return the value of and remove the head of the Linked List.
\item \texttt{push(node)}: make node the head of the Linked List.\\
\texttt{pop()}: return the value of and remove the tail of the Linked List.
\item \texttt{push(node)}: make node the head of the Linked List. \\
\texttt{pop()}: return the value of and remove the head of the Linked List.  \ifdraft \Ans \fi 
\end{enumerate}


\end{enumerate}
\end{document}
